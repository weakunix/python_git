Logic:
Our immediate reaction could be to use dp to solve this problem. Using a simple paths on 2d grid algorithm yields the time complexity O(N^4) which is much too slow. One can store a prefix sum for the number of paths to get to (C - 1, R - 1) and prefix sums for each color. This reduces the time complexity to O(N^3) but that's still to slow. One important realization is that not every color appears on every row. More specifically, if we have every color appearing on each row, we have N colors at most. If there are more than N colors, it can be proven that some colors don't appear on certain rows. This motivates a compression for our prefix sums. Also, instead of keeping N prefix sums for each color, we can just keep one for each color. When we move from column i to i - 1, we can just reuse the same prefix sum. This does require an extra step, which is to keep extra counters, one for each color and the total ways, that store the number of paths just from this column. This avoids multiple counting. All of this reduces the time complexity but is ultimately still too slow. The reason for this is because everytime we move up a column, we have to update at most N colors which yields the time complexity O(N^3). Let's look at an example:

Suppose we have a grid as follows:

1 2 2 2
2 1 2 2
1 2 2 2
2 2 2 2

Let's just look at 1
1's color prefix looks like [0, 0, 0] where each index corresponds to y = 2, 1, 0
When we consider the 1 at (1, 1), we update the prefix sum to be [0, 1, 0]
When we consider the 1 at (0, 2), we update the prefix sum to be [1, 1, 0]
But this is wrong because the prefix sum needs to be [1, 2, 0]

A solution for this is to use binary indexed trees. This way, we can update the prefix sum in O(logN) time. This yields the complexity O(N^2logN) which passes.

Approach 1 (slowcomp.cpp):
However, it's worth noting that this approach's compression is too slow. It's so slow that just on it's own, it receives tle. It looks like an O(N^2logN) compression so I'm not sure why it's too slow.

Approach 2 (CowHopscotch.cpp):
We can just use an unordered_set and an unordered_map to resolve this issue. We don't need to compress 1->0, 2->1, etc. It doesn't matter. We can assign 1->1 and 2->0. This will reduce the logN factor to constant which is just fast enough to pass.

Takeaways:
-Try thinking of slower solutions first
    -If you find a way that actually works, great!
    -But if not, that can help guide you towards a faster solution
        -It also can help explain the rational behind using certain algorithms or data structures
